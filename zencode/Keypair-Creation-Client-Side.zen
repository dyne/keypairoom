Scenario 'ecdh': Create the key
Scenario 'ethereum': Create key
Scenario 'reflow': Create the key
Scenario 'schnorr': Create the key
Scenario 'eddsa': Create the key
Scenario 'qp': Create the key


# Loading the user name from data
Given my name is in a 'string' named 'username'

# Loading the answers from 3 secret questions. The user will have to pick the 3 challenges from a list 
# and have to remember the questions - the order is not important cause Zenroom will sort alphabetically 
# the data in input
#
# NOTE: the challenges will never be communicated to the server or to anybody else!
Given I have a 'string dictionary' named 'userChallenges'

# Loading the individual challenges, in order to have them hashed 
# and the hashes OPTIONALLY stored by the server, to improve regeneration of the keypair
Given I have a 'string' named 'question1' in 'userChallenges'
Given I have a 'string' named 'question2' in 'userChallenges'
Given I have a 'string' named 'question3' in 'userChallenges'
Given I have a 'string' named 'question4' in 'userChallenges'
Given I have a 'string' named 'question5' in 'userChallenges'

# Loading the pbkdf received from the server, containing a signed hash of known data
Given that I have a 'base64' named 'seedServerSideShard.HMAC'  

When I copy 'seedServerSideShard.HMAC' to 'password'

# Hashing the user's challenges and renaming it
When I create the key derivation of 'userChallenges' with password 'password'
#When I create the key derivation of 'userChallenges'
and I rename the 'key derivation' to 'userChallenges.pbkdf'

# appending the user challenges' hash to the pbkdf, hashing the result and renaming it 
When I append 'userChallenges.pbkdf' to 'seedServerSideShard.HMAC'


When I create the key derivation of 'seedServerSideShard.HMAC' with password 'password'
and I rename the 'key derivation' to 'seed'

# Creating the keypair from the hash just created
#When I create the keypair with secret key 'concatenatedHashes'

When I seed the random with 'seed'

When I create the ecdh key
When I create the eddsa key
When I create the ethereum key 
When I create the reflow key
When I create the schnorr key

When I create the ecdh public key
When I create the eddsa public key
When I create the ethereum address
When I create the reflow public key
When I create the schnorr public key



When I create the 'base64 dictionary'
and I rename the 'base64 dictionary' to 'hashedAnswers'


# Creating the hashes of the single challenges, to OPTIONALLY help 
# regeneration of the keypair

When I create the hash of 'question1'
and I rename the 'hash' to 'question1.hash'
When I insert 'question1.hash' in 'hashedAnswers'

When I create the hash of 'question2'
and I rename the 'hash' to 'question2.hash'
When I insert 'question2.hash' in 'hashedAnswers'

When I create the hash of 'question3'
and I rename the 'hash' to 'question3.hash'
When I insert 'question3.hash' in 'hashedAnswers'

When I create the hash of 'question4'
and I rename the 'hash' to 'question4.hash'
When I insert 'question4.hash' in 'hashedAnswers'

When I create the hash of 'question5'
and I rename the 'hash' to 'question5.hash'
When I insert 'question5.hash' in 'hashedAnswers'


# This prints the keyring
Then print the 'keyring'

# this prints the hashes of the challenges
Then print the 'hashedAnswers'

# This prints the seed for the private keys as mnemonic 
Then print the 'seed' as 'mnemonic'

Then print the 'ecdh public key'
Then print the 'eddsa public key'
Then print the 'ethereum address'
Then print the 'reflow public key'
Then print the 'schnorr public key'
